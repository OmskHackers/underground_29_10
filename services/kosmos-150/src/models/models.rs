// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]

use chrono::{NaiveDateTime, Utc, NaiveDate};
use diesel::dsl::count;
use diesel::{RunQueryDsl, QueryDsl, ExpressionMethods};
use diesel::prelude::*;
use crate::schema::spaceports::{id, name, star_system, location};
use crate::schema::{users, spaceports, spaceships, flights, orders};

use crate::utils::date;
use crate::{error::AppError, pkg::db};

#[derive(Queryable, Insertable, Debug)]
pub struct User {
    pub id: i32,
    pub username: String,
    pub password: String,
}

impl User {
    pub fn create(username: String, password: String) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn) => {
                let res = diesel::insert_into(users::table)
                    .values((
                        users::username.eq(username),
                        users::password.eq(password)
                    ))
                    .get_result(&mut conn);
                match res {
                    Ok(u)=> Ok(u),
                    Err(e) => Err(AppError::new(e.to_string()))
                } 
            }
            Err(e) => Err(e)
        }
    }
    pub fn find(username: String) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn) => {
                let res = users::table
                    .filter(users::username.eq(username))
                    .first(&mut conn);
                match res {
                    Ok(user) => Ok(user),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }

    pub fn get_username(&self) -> String {
        self.username.clone()
    }
}

#[derive(Queryable, Identifiable, PartialEq, Debug)]
pub struct Spaceport {
    pub id: i32,
    pub name: String,
    pub star_system: String,
    pub location: String,
}

impl Spaceport {
    pub fn find_all() -> Result<Vec<Self>, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = spaceports::table.load(&mut conn);
                match res {
                    Ok(res) => Ok(res),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn find_by_id(spaceport_id: i32) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = spaceports::table
                    .filter(
                        spaceports::id.eq(spaceport_id)
                    )
                    .first(&mut conn);
                match res {
                    Ok(res) => Ok(res),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
}

#[derive(Queryable, Identifiable, PartialEq, Debug)]
pub struct Spaceship {
    pub id: i32,
    pub name: String,
    pub seats_number: i32
}

impl Spaceship {
    pub fn find_all() -> Result<Vec<Self>, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = spaceships::table.load(&mut conn);
                match res {
                    Ok(res) => Ok(res),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn find_by_id(spaceship_id: i32) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = spaceships::table
                    .filter(
                        spaceships::id.eq(spaceship_id)
                    )
                    .first(&mut conn);
                match res {
                    Ok(res) => Ok(res),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn find_by_order(order_id: i32) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = flights::table
                    .inner_join(orders::table)
                    .inner_join(spaceships::table)
                    .filter(orders::id.eq(order_id))
                    .first::<(Flight, Order, Spaceship)>(&mut conn);
                match res {
                    Ok(tuple) => Ok(tuple.2),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
}

#[derive(Debug, Identifiable, Queryable, Insertable)]
#[diesel(belongs_to(Spaceship))]
#[diesel(belongs_to(Spaceport, foreign_key = from_spaceport_id))]
#[diesel(belongs_to(Spaceport, foreign_key = to_spaceport_id))]
pub struct Flight {
    pub id: i32,
    pub spaceship_id: i32,
    pub from_spaceport_id: i32,
    pub to_spaceport_id: i32,
    pub departure: NaiveDateTime
}

impl Flight {
    pub fn create(spaceship: &Spaceship, departure_spaceport: &Spaceport, arrival_spaceport: &Spaceport, departure: NaiveDateTime) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn) => {
                let res = diesel::insert_into(flights::table)
                    .values((
                        flights::spaceship_id.eq(spaceship.id),
                        flights::from_spaceport_id.eq(departure_spaceport.id),
                        flights::to_spaceport_id.eq(arrival_spaceport.id),
                        flights::departure.eq(departure)
                    ))
                    .get_result(&mut conn);
                match res {
                    Ok(u)=> Ok(u),
                    Err(e) => Err(AppError::new(e.to_string()))
                } 
            }
            Err(e) => Err(e)
        }
    }
    pub fn find_arriving() -> Result<Vec<Self>, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let now = Utc::now().naive_utc();
                let res = flights::table
                    .filter(flights::departure.gt(now))
                    .load(&mut conn);
                match res {
                    Ok(flights) => Ok(flights),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn find_by_id(flight_id: i32) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let now = Utc::now().naive_utc();
                let res = flights::table
                    .filter(flights::id.eq(flight_id))
                    .first(&mut conn);
                match res {
                    Ok(flight) => Ok(flight),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
}

#[derive(Queryable, Insertable, Debug)]
#[diesel(belongs_to(Flight, foreign_key = flight_id))]
#[diesel(belongs_to(User, foreign_key = user_id))]
pub struct Order {
    pub id: i32,
    pub user_id: i32,
    pub flight_id: i32,
    pub occupied_seat: i32,
    pub comment: Option<String>
}

impl Order {
    pub fn create(order: Order) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = diesel::insert_into(orders::table)
                    .values((
                        orders::flight_id.eq(order.flight_id),
                        orders::user_id.eq(order.user_id),
                        orders::occupied_seat.eq(order.occupied_seat),
                        orders::comment.eq(order.comment)
                    ))
                    .get_result(&mut conn);
                match res {
                    Ok(order) => Ok(order),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn find_orders_by_user(user_id: i32) -> Result<Vec<Self>, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = orders::table
                    .filter(orders::user_id.eq(user_id))
                    .load(&mut conn);
                match res {
                    Ok(order) => Ok(order),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn count_flight_orders(flight_id: i32) -> Result<i64, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res: Result<i64, _> = orders::table
                    .filter(orders::flight_id.eq(flight_id))
                    .select(count(orders::id))
                    .first(&mut conn);
                match res {
                    Ok(counter) => Ok(counter),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn find_flight_order_by_seat(flight_id: i32, seat_number: i32) -> Result<Order, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = orders::table
                    .filter(
                        orders::flight_id.eq(flight_id)
                    )
                    .filter(
                        orders::occupied_seat.eq(seat_number)
                    )
                    .first(&mut conn);
                match res {
                    Ok(order) => Ok(order),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }   
    pub fn find_by_id(user_id: i32, order_id: i32) -> Result<Self, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = orders::table
                    .filter(
                        orders::id.eq(order_id).or(orders::user_id.eq(user_id))
                    )
                    .first(&mut conn);
                match res {
                    Ok(order) => Ok(order),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
    pub fn get_order_occupied_seats(order_id: i32) -> Result<Vec<i32>, AppError> {
        let conn_res = db::connection();
        match conn_res {
            Ok(mut conn)=> {
                let res = orders::table
                    .select(orders::occupied_seat)
                    .filter(orders::id.eq(order_id))
                    .load(&mut conn);
                match res {
                    Ok(occupied_seats) => Ok(occupied_seats),
                    Err(e) => Err(AppError::new(e.to_string()))
                }
            }
            Err(e) => Err(e)
        }
    }
}